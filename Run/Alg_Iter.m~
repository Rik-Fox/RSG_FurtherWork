function Alg_Iter(no_algs, input, output, stochruns)

    Algors = readtable(string(input));

    % fprintf("hello\n\n")

    Algor_varient = Algors.name; %extract paths
    Algor_type = Algors.Algs;
    % all algorithm paths would be this length(Algor_varient)

    load_Data = load('Input_Data/Data.mat'); %Loads Bandundu data from Data directory

    load('Input_Data/Paras_DRC100.mat', 'FittedParameters', 'FixedParameters', 'InterventionParameters') %Params for DRC

    fittedparas = FittedParameters(FittedParameters.Location == "DRC", :); % find all top level params

    %%% using M4 values to make it run, need to confirm correct choice

    fittedparas = fittedparas(fittedparas.Model ~= "M5M8", :);
    fittedparas = fittedparas(fittedparas.Model ~= "M7M8", :);

    Unique_to_Bandundu = FittedParameters(FittedParameters.Location == "P1_Bandundu", :); %params specified for Bandundu (Province)

    for i = 1:length(Unique_to_Bandundu.Notation) % replace with / add Bandundu params

        try
            fittedparas(fittedparas.Notation == string(Unique_to_Bandundu.Notation(i)), :) = Unique_to_Bandundu(i, :);
        catch
            fittedparas = [fittedparas; Unique_to_Bandundu(i, :)];
        end

    end

    healthzone = 1;
    HZloc = {'Z29_Kwamouth', 'Z35_Mosango', 'Z51_YasaBonga'};

    screentype = 1;

    for hz = 1:healthzone

        location = char(HZloc(:, hz)); %Identifies relevant health zone
        loc_idx = str2double(string(location(2:3)));
        loc_name = load_Data.CCLOC(loc_idx);
        if sum(InterventionParameters.Location == string(location))
            intervention = InterventionParameters(InterventionParameters.Location == string(location), :);
        else
            intervention = InterventionParameters(InterventionParameters.Location == "DRC", :);
        end
        intervention.VCstart = 0;
        intervention.TargetDie = 0;

        load('Input_Data/'+string(loc_idx) + '_Posterior.mat', 'Posterior') %loads in full healthzone posterior
        load('Input_Data/ProjectionICs_M4_DRC_P1_'+string(location)+'_IDDRC100.mat', 'ProjectionICs') %loads in ICs for posterior
        

        FixedParameters.Location = loc_name;

        Paras = table2struct([cell2table(num2cell(fittedparas.Initial)', 'VariableNames', fittedparas.Notation'), FixedParameters, intervention(1, 2:end)]); % input parameters for main functions

        for pst = 1:1
            
            ICs = datasample(ProjectionICs, 1, 1, 'Replace', false); % (data, # of samples, dims)

            posterior = Posterior(ICs.PostID, :);
            post_names = posterior.Properties.VariableNames;

            for i = 1:length(post_names)                              % replace paras with healtzone fitted paras
                Paras.(string(post_names(i))) = posterior.(string(post_names(i)));
            end

            Paras.PostID = ICs.PostID;

            writetable(struct2table(Paras, 'AsArray', true), "Output_Data/Post#"+ string(pst) + "_pre2016_Paras.csv")

            %%% load in data fresh for each posterior

            Data = struct('Years', load_Data.YEAR, 'N_H', load_Data.PopSize(loc_idx), 'PopSizeYear', load_Data.PopSizeYear, ...
                'PeopleScreened', load_Data.SCREENED(loc_idx, :), 'ActiveD1', load_Data.ACTIVE1(loc_idx, :), ...
                'ActiveD2', load_Data.ACTIVE2(loc_idx, :), 'ActiveDNa', load_Data.ACTIVENa(loc_idx, :), ...
                'PassiveD1', load_Data.PASSIVE1(loc_idx, :), 'PassiveD2', load_Data.PASSIVE2(loc_idx, :), ...
                'PassiveDNa', load_Data.PASSIVENa(loc_idx, :)); % input data for main functions

           
            writetable(struct2table(Data, 'AsArray', true), "Output_Data/Post#"+ string(pst) + "_pre2016_Data.csv")

           
            for scr = 1:screentype

                
                %%% from current year onwards

                Data.Years = Data.Years(end) + 1:2050;

                if scr == 1
                    %held constant at mean of last 5 years
                    Synthetic_Screen2 = ones(1, length(Data.Years)) * mean(Data.PeopleScreened(end - 5:end));
                elseif scr == 2
                    % 5 year sampling
                    Synthetic_Screen2 = datasample(Data.PeopleScreened(end - 5:end), length(Data.Years));
                elseif scr == 3
                    % 5 year rolling average
                    prev = Data.PeopleScreened(end - 5:end);

                    for i = 1:length(Data.Years)
                        Synthetic_Screen2(i) = mean(prev);
                        prev = [prev(2:end), Synthetic_Screen(i)];
                    end

                end

                % Sampling from fitted dynamics
                MtoAbsScaling2 = Paras.PopGrowth.^double(Data.Years - Data.PopSizeYear); % 1.03 = PopGrowth, is hard coded as all data has the same
                Pop2 = round(Data.N_H * MtoAbsScaling2);
                ScaledPeopleScreened2 = Synthetic_Screen2 ./ MtoAbsScaling2;

                %Algorithm for assigning multiple screenings per year based on data (could
                %change by region/country etc.)
                Frequency = [];
                Screen = [];
                Y = [];

                for i = 1:length(Data.Years)

                    if ScaledPeopleScreened2(i) < Data.N_H * 0.8
                        Frequency = [Frequency 365];
                        Y = [Y Data.Years(i)];
                        Screen = [Screen ScaledPeopleScreened2(i)];
                    else
                        Frequency = [Frequency ceil(365/2) floor(365/2)];
                        Screen = [Screen ScaledPeopleScreened2(i) / 2 ScaledPeopleScreened2(i) / 2];
                        Y = [Y Data.Years(i) Data.Years(i) + 0.5];

                    end

                end

                Data.ModelScreeningFreq = Frequency;
                Data.ModelScreeningTime = Y;
                Data.ModelPeopleScreened = Screen;

                writetable(struct2table(Data, 'AsArray', true), "Output_Data/Post#"+ string(pst) + "_"+ scrname + "_Future_Data.csv")

                for itr = 1:no_algs

                    Paras.Sensitivity = Algors.MeanSens(itr);
                    Paras.Specificity = Algors.MeanSpec(itr);

                    [Classes2, Aggregate2] = ODEHATmodel(meff, ICs, Data, Paras, 0);

                    writetable([Classes0; Classes1; Classes2], "Output_Data/"+ Algor_varient(itr) + "_Post#"+ string(pst) + "_"+ scrname + "_Classes.csv", 'WriteRowNames', true);
                    writetable([Aggregate0; Aggregate1; Aggregate2], "Output_Data/"+ Algor_varient(itr) + "_Post#"+ string(pst) + "_"+ scrname + "_Aggregate.csv", 'WriteRowNames', true);

                    ElimDist = table(-1, -1, -1);

                    for sr = 1:stochruns
                        [Classes, Aggregate, Elim] = StochasticHATmodel(meff, ICs, Data, Paras, 0);

                        writetable([Classes0; Classes1; Classes], "Output_Data/"+ Algor_varient(itr) + "_Post#"+ string(pst) + "_"+ scrname + "_Stoch#"+ string(sr) + "_Classes.csv", 'WriteRowNames', true);
                        writetable([Aggregate0; Aggregate1; Aggregate], "Output_Data/"+ Algor_varient(itr) + "_Post#"+ string(pst) + "_"+ scrname + "_Stoch#"+ string(sr) + "_Aggregate.csv", 'WriteRowNames', true);

                        ElimDist = [ElimDist; table(Elim.Trans, Elim.Report, Elim.Inf)];
                        fprintf('stoch=' + string(sr) + "\n")
                    end

                    ElimDist.Properties.VariableNames = {'TransElimYear', 'ReportElimYear', 'InfElimYear'};

                    ElimDist(2:end, :)

                    writetable(ElimDist(2:end, :), "Output_Data/"+ Algor_varient(itr) + "_Post#"+ string(pst) + "_"+ scrname + "_ElimDist.csv");

                    fprintf(string(itr) + "\n")

                end

            end

        end

        fprintf("done \n\n");
        %quit;
    end
